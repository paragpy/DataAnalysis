"""
Optimized Graph Schema Validator for NebulaGraph
Validates and transforms data according to TOML schema definitions.
"""
from __future__ import annotations

import re
from dataclasses import dataclass, field
from datetime import datetime, timezone, date, time
from pathlib import Path
from typing import Any, Literal

import toml


# ============================================================================
# Exceptions
# ============================================================================
class SchemaError(Exception):
    """Raised when schema definition is invalid."""
    pass


class ValidationError(Exception):
    """Raised when data validation fails."""
    pass


# ============================================================================
# Constants & Utilities
# ============================================================================
SEMVER_PATTERN = re.compile(
    r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:[-+][A-Za-z0-9\.-]+)?$"
)

FIXED_STRING_PATTERN = re.compile(r"FIXED_STRING\s*\(\s*(\d+)\s*\)", re.IGNORECASE)

# Supported Nebula types
NEBULA_TYPES = {
    "STRING", "FIXED_STRING", "BOOL", "INT", "INT8", "INT16", "INT32", "INT64",
    "FLOAT", "DOUBLE", "TIMESTAMP", "DATETIME", "DATE", "TIME"
}


def parse_timestamp(value: Any) -> int:
    """
    Parse various timestamp formats into Unix timestamp (seconds).
    For TIMESTAMP type in NebulaGraph.
    
    Supports:
    - datetime objects
    - Unix timestamps (int/float)
    - ISO 8601 strings
    - 'now()' function
    
    Returns integer Unix timestamp in seconds.
    """
    if isinstance(value, (int, float)):
        return int(value)
    
    if isinstance(value, datetime):
        dt = value.astimezone(timezone.utc) if value.tzinfo else value.replace(tzinfo=timezone.utc)
        return int(dt.timestamp())
    
    if isinstance(value, str):
        normalized = value.strip().lower()
        
        # Handle 'now()' function
        if normalized in ("now()", "now"):
            return int(datetime.now(tz=timezone.utc).timestamp())
        
        # Parse ISO 8601
        try:
            dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
            dt = dt.astimezone(timezone.utc) if dt.tzinfo else dt.replace(tzinfo=timezone.utc)
            return int(dt.timestamp())
        except ValueError:
            pass
    
    raise ValidationError(f"Invalid timestamp value: {value!r}")


def parse_datetime(value: Any) -> datetime:
    """
    Parse various datetime formats into timezone-aware datetime.
    For DATETIME type in NebulaGraph.
    
    Supports:
    - datetime objects
    - Unix timestamps (int/float)
    - ISO 8601 strings
    - 'now()' function
    
    Returns timezone-aware datetime object.
    """
    if isinstance(value, datetime):
        return value.astimezone(timezone.utc) if value.tzinfo else value.replace(tzinfo=timezone.utc)
    
    if isinstance(value, (int, float)):
        return datetime.fromtimestamp(value, tz=timezone.utc)
    
    if isinstance(value, str):
        normalized = value.strip().lower()
        
        # Handle 'now()' function
        if normalized in ("now()", "now"):
            return datetime.now(tz=timezone.utc)
        
        # Parse ISO 8601
        try:
            dt = datetime.fromisoformat(value.replace("Z", "+00:00"))
            return dt.astimezone(timezone.utc) if dt.tzinfo else dt.replace(tzinfo=timezone.utc)
        except ValueError:
            pass
    
    raise ValidationError(f"Invalid datetime value: {value!r}")


def parse_date(value: Any) -> str:
    """
    Parse date and return as ISO 8601 string for NebulaGraph DATE type.
    Format: YYYY-MM-DD
    """
    if isinstance(value, str):
        # Validate and normalize the date string
        try:
            parsed = datetime.fromisoformat(value.strip()).date()
            return parsed.isoformat()
        except ValueError:
            pass
    
    if isinstance(value, date):
        return value.isoformat()
    
    if isinstance(value, datetime):
        return value.date().isoformat()
    
    raise ValidationError(f"Invalid date value: {value!r}")


def parse_time(value: Any) -> str:
    """
    Parse time and return as ISO 8601 string for NebulaGraph TIME type.
    Format: HH:MM:SS or HH:MM:SS.ffffff
    """
    if isinstance(value, str):
        # Validate and normalize the time string
        try:
            parsed = datetime.fromisoformat(f"2000-01-01T{value.strip()}").time()
            return parsed.isoformat()
        except ValueError:
            pass
    
    if isinstance(value, time):
        return value.isoformat()
    
    if isinstance(value, datetime):
        return value.time().isoformat()
    
    raise ValidationError(f"Invalid time value: {value!r}")


def to_bool(value: Any) -> bool:
    """Convert various types to boolean."""
    if isinstance(value, bool):
        return value
    
    if isinstance(value, (int, float)):
        return value != 0
    
    if isinstance(value, str):
        normalized = value.strip().lower()
        return normalized in {"1", "true", "t", "yes", "y", "on"}
    
    raise ValidationError(f"Invalid boolean value: {value!r}")


# ============================================================================
# Type System
# ============================================================================
@dataclass(frozen=True)
class NebulaType:
    """Represents a NebulaGraph data type."""
    
    base: str
    size: int | None = None
    
    @classmethod
    def parse(cls, type_str: str) -> NebulaType:
        """Parse type string into NebulaType object."""
        normalized = type_str.strip().upper()
        
        # Handle FIXED_STRING(N)
        if normalized.startswith("FIXED_STRING"):
            match = FIXED_STRING_PATTERN.search(normalized)
            if not match:
                raise SchemaError(f"Invalid FIXED_STRING specification: {type_str}")
            return cls(base="FIXED_STRING", size=int(match.group(1)))
        
        # Validate base type
        if normalized not in NEBULA_TYPES:
            raise SchemaError(f"Unsupported type: {type_str}")
        
        return cls(base=normalized)
    
    def __str__(self) -> str:
        return f"{self.base}({self.size})" if self.size else self.base


# ============================================================================
# Type Converter
# ============================================================================
class TypeConverter:
    """Converts Python values to NebulaGraph types with validation."""
    
    __slots__ = ("truncate_strings",)
    
    def __init__(self, truncate_strings: bool = False):
        self.truncate_strings = truncate_strings
    
    def convert(self, value: Any, nebula_type: NebulaType) -> Any:
        """Convert and validate value according to NebulaType."""
        base = nebula_type.base
        
        # String types
        if base in ("STRING", "FIXED_STRING"):
            return self._convert_string(value, nebula_type)
        
        # Boolean
        if base == "BOOL":
            return to_bool(value)
        
        # Integer types
        if base in ("INT", "INT8", "INT16", "INT32", "INT64"):
            return self._convert_int(value, base)
        
        # Float types
        if base in ("FLOAT", "DOUBLE"):
            return self._convert_float(value)
        
        # Temporal types - return datetime object for TIMESTAMP/DATETIME
        if base in ("TIMESTAMP", "DATETIME"):
            return parse_timestamp(value)
        
        # Return ISO string for DATE
        if base == "DATE":
            return parse_date(value)
        
        # Return ISO string for TIME
        if base == "TIME":
            return parse_time(value)
        
        raise SchemaError(f"Unsupported type for conversion: {base}")
    
    def _convert_string(self, value: Any, nebula_type: NebulaType) -> str:
        """Convert to string with optional length validation."""
        # Never return None, convert to empty string
        string_val = "" if value is None else str(value)
        
        if nebula_type.base == "FIXED_STRING" and nebula_type.size:
            max_len = nebula_type.size
            if len(string_val) > max_len:
                if self.truncate_strings:
                    return string_val[:max_len]
                raise ValidationError(
                    f"String length {len(string_val)} exceeds FIXED_STRING({max_len}) limit"
                )
        
        return string_val
    
    def _convert_int(self, value: Any, type_name: str) -> int:
        """Convert to integer with range validation."""
        try:
            int_val = int(value)
        except (ValueError, TypeError):
            raise ValidationError(f"Cannot convert {value!r} to integer")
        
        # Validate range based on type
        ranges = {
            "INT8": (-128, 127),
            "INT16": (-32768, 32767),
            "INT32": (-2147483648, 2147483647),
            "INT64": (-9223372036854775808, 9223372036854775807),
        }
        
        if type_name in ranges:
            min_val, max_val = ranges[type_name]
            if not (min_val <= int_val <= max_val):
                raise ValidationError(f"Value {int_val} out of range for {type_name}")
        
        return int_val
    
    def _convert_float(self, value: Any) -> float:
        """Convert to float."""
        try:
            return float(value)
        except (ValueError, TypeError):
            raise ValidationError(f"Cannot convert {value!r} to float")


# ============================================================================
# Schema Specifications
# ============================================================================
@dataclass
class PropertySpec:
    """Specification for a tag or edge property."""
    
    name: str
    nebula_type: NebulaType
    nullable: bool
    default: Any | None
    comment: str | None = None
    
    def has_default(self) -> bool:
        """Check if property has a default value."""
        return self.default is not None


@dataclass
class TagSpec:
    """Specification for a tag (vertex) type."""
    
    name: str
    properties: dict[str, PropertySpec] = field(default_factory=dict)
    comment: str | None = None


@dataclass
class EdgeSpec:
    """Specification for an edge type."""
    
    name: str
    properties: dict[str, PropertySpec] = field(default_factory=dict)
    comment: str | None = None


@dataclass
class ValidationRules:
    """Domain-specific validation rules."""
    
    require_non_empty_name: bool = False
    require_semver_version: bool = False
    allowed_types: list[str] | None = None
    enforce_vid_length: int | None = None


# ============================================================================
# Schema Registry
# ============================================================================
class SchemaRegistry:
    """
    Registry of graph schema definitions loaded from TOML.
    
    Provides fast lookup for tags, edges, and validation rules.
    """
    
    __slots__ = ("_raw_data", "tags", "edges", "rules", "space_config")
    
    def __init__(self, schema_data: dict):
        self._raw_data = schema_data
        self.tags: dict[str, TagSpec] = {}
        self.edges: dict[str, EdgeSpec] = {}
        self.rules = ValidationRules()
        self.space_config: dict[str, Any] = {}
        self._load_schema()
    
    @classmethod
    def from_toml(cls, path_or_content: str | Path) -> SchemaRegistry:
        """
        Load schema from TOML file or string.
        
        Args:
            path_or_content: File path or TOML content string
            
        Returns:
            SchemaRegistry instance
        """
        path = Path(path_or_content)
        
        if path.exists() and path.is_file():
            with path.open("r", encoding="utf-8") as f:
                data = toml.load(f)
        else:
            # Treat as TOML string content
            data = toml.loads(str(path_or_content))
        
        return cls(data)
    
    def _load_schema(self):
        """Load and parse schema from raw TOML data."""
        # Load space configuration
        self.space_config = self._raw_data.get("space", {})
        
        # Load tags
        raw_tags = self._raw_data.get("tags", {})
        for tag_name, tag_data in raw_tags.items():
            if not isinstance(tag_data, dict):
                continue
            
            properties = self._parse_properties(tag_data.get("properties", {}))
            self.tags[tag_name] = TagSpec(
                name=tag_name,
                properties=properties,
                comment=tag_data.get("comment")
            )
        
        # Load edges
        raw_edges = self._raw_data.get("edges", {})
        for edge_name, edge_data in raw_edges.items():
            if not isinstance(edge_data, dict):
                continue
            
            properties = self._parse_properties(edge_data.get("properties", {}))
            self.edges[edge_name] = EdgeSpec(
                name=edge_name,
                properties=properties,
                comment=edge_data.get("comment")
            )
        
        # Load validation rules
        rules_data = self._raw_data.get("validation", {}).get("rules", {})
        self.rules = ValidationRules(
            require_non_empty_name=rules_data.get("require_non_empty_name", False),
            require_semver_version=rules_data.get("require_semver_version", False),
            allowed_types=rules_data.get("allowed_types"),
            enforce_vid_length=rules_data.get("enforce_vid_length")
        )
    
    def _parse_properties(self, props_data: dict) -> dict[str, PropertySpec]:
        """Parse property specifications from TOML data."""
        properties = {}
        
        for prop_name, prop_data in props_data.items():
            if not isinstance(prop_data, dict):
                continue
            
            properties[prop_name] = PropertySpec(
                name=prop_name,
                nebula_type=NebulaType.parse(prop_data["type"]),
                nullable=prop_data.get("nullable", True),
                default=prop_data.get("default"),
                comment=prop_data.get("comment")
            )
        
        return properties
    
    def get_tag(self, name: str) -> TagSpec:
        """Get tag specification by name."""
        if name not in self.tags:
            raise SchemaError(f"Unknown tag type: {name}")
        return self.tags[name]
    
    def get_edge(self, name: str) -> EdgeSpec:
        """Get edge specification by name."""
        if name not in self.edges:
            raise SchemaError(f"Unknown edge type: {name}")
        return self.edges[name]
    
    def has_tag(self, name: str) -> bool:
        """Check if tag exists in schema."""
        return name in self.tags
    
    def has_edge(self, name: str) -> bool:
        """Check if edge exists in schema."""
        return name in self.edges


# ============================================================================
# Validator Options
# ============================================================================
@dataclass
class ValidatorOptions:
    """Configuration options for validation behavior."""
    
    truncate_strings: bool = False
    forbid_unknown_properties: bool = True
    apply_defaults: bool = True
    strict_mode: bool = True


# ============================================================================
# Graph Validator
# ============================================================================
class GraphValidator:
    """
    Validates and transforms graph data according to schema definitions.
    
    Features:
    - Type conversion and validation
    - Default value application
    - Domain rule enforcement
    - VID validation
    """
    
    __slots__ = ("registry", "options", "converter")
    
    def __init__(
        self,
        registry: SchemaRegistry,
        options: ValidatorOptions | None = None
    ):
        self.registry = registry
        self.options = options or ValidatorOptions()
        self.converter = TypeConverter(truncate_strings=self.options.truncate_strings)
    
    # ========================================================================
    # Public API
    # ========================================================================
    
    def validate_tag(self, tag_name: str, properties: dict[str, Any]) -> dict[str, Any]:
        """
        Validate and transform tag properties.
        
        Args:
            tag_name: Name of the tag type
            properties: Property values to validate
            
        Returns:
            Validated and transformed properties
        """
        spec = self.registry.get_tag(tag_name)
        validated = self._validate_properties(
            properties,
            spec.properties,
            entity_type="Tag",
            entity_name=tag_name
        )
        self._apply_domain_rules(validated, entity_name=f"Tag[{tag_name}]")
        return validated
    
    def validate_edge(self, edge_name: str, properties: dict[str, Any]) -> dict[str, Any]:
        """
        Validate and transform edge properties.
        
        Args:
            edge_name: Name of the edge type
            properties: Property values to validate
            
        Returns:
            Validated and transformed properties
        """
        spec = self.registry.get_edge(edge_name)
        validated = self._validate_properties(
            properties,
            spec.properties,
            entity_type="Edge",
            entity_name=edge_name
        )
        return validated
    
    def validate_vid(self, vid: str | None) -> str:
        """
        Validate vertex ID according to schema rules.
        
        Args:
            vid: Vertex ID to validate
            
        Returns:
            Validated vertex ID
        """
        if vid is None:
            raise ValidationError("VID cannot be None")
        
        vid_str = str(vid).strip()
        
        if not vid_str:
            raise ValidationError("VID cannot be empty")
        
        # Check length constraint if defined
        max_length = self.registry.rules.enforce_vid_length
        if max_length and len(vid_str) > max_length:
            raise ValidationError(
                f"VID length {len(vid_str)} exceeds maximum {max_length}"
            )
        
        return vid_str
    
    def validate_payload(self, payload: dict[str, Any]) -> dict[str, Any]:
        """
        Validate a complete payload with entity type, properties, and optional VID.
        
        Expected payload structure:
        {
            "entity": "tag" | "edge",
            "type": "<tag_name>" | "<edge_name>",
            "vid": "<vertex_id>",  # for tags only
            "props": { ... }
        }
        
        Returns:
            Validated payload with transformed properties
        """
        entity = payload.get("entity", "").lower()
        entity_type = payload.get("type")
        vid = payload.get("vid")
        properties = payload.get("props", {})
        
        # Validate entity type
        if entity not in ("tag", "edge"):
            raise ValidationError("entity must be 'tag' or 'edge'")
        
        if not entity_type or not isinstance(entity_type, str):
            raise ValidationError("type must be a non-empty string")
        
        # Validate based on entity type
        if entity == "tag":
            validated_vid = self.validate_vid(vid)
            validated_props = self.validate_tag(entity_type, properties)
            
            return {
                "entity": "tag",
                "type": entity_type,
                "vid": validated_vid,
                "props": validated_props
            }
        else:
            validated_props = self.validate_edge(entity_type, properties)
            
            return {
                "entity": "edge",
                "type": entity_type,
                "props": validated_props
            }
    
    # ========================================================================
    # Internal Implementation
    # ========================================================================
    
    def _validate_properties(
        self,
        input_props: dict[str, Any],
        prop_specs: dict[str, PropertySpec],
        entity_type: str,
        entity_name: str
    ) -> dict[str, Any]:
        """Core property validation and transformation logic."""
        validated: dict[str, Any] = {}
        entity_label = f"{entity_type}[{entity_name}]"
        
        # Check for unknown properties
        if self.options.forbid_unknown_properties:
            unknown = set(input_props) - set(prop_specs)
            if unknown:
                raise ValidationError(
                    f"{entity_label}: Unknown properties: {', '.join(sorted(unknown))}"
                )
        
        # Process each property in schema
        for prop_name, spec in prop_specs.items():
            raw_value = input_props.get(prop_name)
            has_value = prop_name in input_props
            
            # Handle missing or null values
            if not has_value or raw_value is None:
                # Try to apply default first
                if self.options.apply_defaults and spec.has_default():
                    default_value = self._resolve_default(spec)
                    validated[prop_name] = self.converter.convert(default_value, spec.nebula_type)
                elif spec.nullable:
                    # Only set None if explicitly nullable and no default available
                    if spec.has_default():
                        default_value = self._resolve_default(spec)
                        validated[prop_name] = self.converter.convert(default_value, spec.nebula_type)
                    else:
                        # Return default value based on type instead of None
                        validated[prop_name] = self._get_type_default(spec.nebula_type)
                else:
                    raise ValidationError(
                        f"{entity_label}: Required non-nullable property '{prop_name}' is missing or None"
                    )
                continue
            
            # Convert and validate value
            try:
                validated[prop_name] = self.converter.convert(raw_value, spec.nebula_type)
            except ValidationError as e:
                raise ValidationError(f"{entity_label}.{prop_name}: {e}") from e
        
        # Pass through unknown properties if allowed
        if not self.options.forbid_unknown_properties:
            for prop_name, value in input_props.items():
                if prop_name not in validated:
                    validated[prop_name] = value
        
        return validated
    
    def _get_type_default(self, nebula_type: NebulaType) -> Any:
        """Get appropriate default value for a type when None is not acceptable."""
        base = nebula_type.base
        
        if base in ("STRING", "FIXED_STRING"):
            return ""
        
        if base == "BOOL":
            return False
        
        if base in ("INT", "INT8", "INT16", "INT32", "INT64"):
            return 0
        
        if base in ("FLOAT", "DOUBLE"):
            return 0.0
        
        if base in ("TIMESTAMP", "DATETIME"):
            return datetime.now(tz=timezone.utc)
        
        if base == "DATE":
            return date.today().isoformat()  # Return ISO string
        
        if base == "TIME":
            return "00:00:00"  # Return ISO string
        
        # Fallback: raise error if no suitable default
        raise ValidationError(f"Cannot determine default value for type {nebula_type}")
    
    def _resolve_default(self, spec: PropertySpec) -> Any:
        """Resolve default value, handling special functions like now()."""
        default = spec.default
        
        # Handle now() function for temporal types
        if isinstance(default, str):
            normalized = default.strip().lower()
            if normalized in ("now()", "now"):
                if spec.nebula_type.base in ("TIMESTAMP", "DATETIME"):
                    return datetime.now(tz=timezone.utc)
        
        return default
    
    def _apply_domain_rules(self, properties: dict[str, Any], entity_name: str):
        """Apply domain-specific validation rules."""
        rules = self.registry.rules
        
        # Rule: non-empty name
        if rules.require_non_empty_name and "name" in properties:
            name_value = properties["name"]
            if name_value is None or str(name_value).strip() == "":
                raise ValidationError(f"{entity_name}: 'name' cannot be empty")
        
        # Rule: semantic versioning
        if rules.require_semver_version and "version_number" in properties:
            version = properties["version_number"]
            if version is not None:
                version_str = str(version).strip()
                if not SEMVER_PATTERN.match(version_str):
                    raise ValidationError(
                        f"{entity_name}: 'version_number' must follow semantic versioning "
                        f"(e.g., 1.2.3), got: {version_str!r}"
                    )
        
        # Rule: allowed types
        if rules.allowed_types and "type" in properties:
            type_value = properties["type"]
            if type_value is not None:
                type_str = str(type_value).lower()
                allowed_lower = [t.lower() for t in rules.allowed_types]
                if type_str not in allowed_lower:
                    raise ValidationError(
                        f"{entity_name}: 'type' must be one of {rules.allowed_types}, "
                        f"got: {type_value!r}"
                    )


# ============================================================================
# Example Usage
# ============================================================================
def main():
    """Example usage of the Graph Schema Validator."""
    
    # Load schema from TOML file
    registry = SchemaRegistry.from_toml("sample_schema.toml")
    
    # Create validator with options
    options = ValidatorOptions(
        truncate_strings=False,
        forbid_unknown_properties=True,
        apply_defaults=True
    )
    validator = GraphValidator(registry, options)
    
    # Example 1: Validate tag properties
    print("=" * 60)
    print("Example 1: Validating Policy Tag")
    print("=" * 60)
    
    policy_data = {
        "name": "Information Security Policy",
        "type": "policy",
        "business_scope": "Enterprise-wide ISMS",
        "version_number": "2.1.0",
        "created_at": "now()",
        "is_active": True
    }
    
    try:
        validated_policy = validator.validate_tag("Policy", policy_data)
        print("✓ Validation successful!")
        print(f"Validated properties: {validated_policy}")
        print(f"Created at (datetime object): {validated_policy['created_at']}")
        print(f"Created at type: {type(validated_policy['created_at'])}")
    except ValidationError as e:
        print(f"✗ Validation failed: {e}")
    
    # Example 2: Validate edge properties
    print("\n" + "=" * 60)
    print("Example 2: Validating HasContent Edge")
    print("=" * 60)
    
    try:
        validated_edge = validator.validate_edge("HasContent", {})
        print("✓ Validation successful!")
        print(f"Validated properties: {validated_edge}")
    except ValidationError as e:
        print(f"✗ Validation failed: {e}")
    
    # Example 3: Validate complete payload
    print("\n" + "=" * 60)
    print("Example 3: Validating Complete Payload")
    print("=" * 60)
    
    payload = {
        "entity": "tag",
        "type": "Addendum",
        "vid": "ADDENDUM-2024-001",
        "props": {
            "name": "Security Controls Addendum",
            "type": "addendum",
            "version_number": "1.0.0",
            "created_at": 1729468800,  # Unix timestamp
            "is_active": "yes"  # String that can be converted to bool
        }
    }
    
    try:
        validated_payload = validator.validate_payload(payload)
        print("✓ Validation successful!")
        print(f"Entity: {validated_payload['entity']}")
        print(f"Type: {validated_payload['type']}")
        print(f"VID: {validated_payload['vid']}")
        print(f"Properties: {validated_payload['props']}")
        print(f"Created at (datetime object): {validated_payload['props']['created_at']}")
        print(f"Created at type: {type(validated_payload['props']['created_at'])}")
    except ValidationError as e:
        print(f"✗ Validation failed: {e}")
    
    # Example 4: Demonstrate validation errors
    print("\n" + "=" * 60)
    print("Example 4: Validation Error Examples")
    print("=" * 60)
    
    invalid_cases = [
        {
            "desc": "Invalid semantic version",
            "data": {"name": "Test", "type": "policy", "version_number": "1.2"}
        },
        {
            "desc": "Missing required property",
            "data": {"type": "policy"}  # 'name' is required
        },
        {
            "desc": "Invalid type value",
            "data": {"name": "Test", "type": "invalid_type", "version_number": "1.0.0"}
        }
    ]
    
    for case in invalid_cases:
        try:
            validator.validate_tag("Policy", case["data"])
            print(f"  {case['desc']}: Unexpectedly passed")
        except ValidationError as e:
            print(f"  {case['desc']}: ✓ Caught error - {e}")
    
    # Example 5: Test None handling with defaults
    print("\n" + "=" * 60)
    print("Example 5: None Value Handling")
    print("=" * 60)
    
    data_with_none = {
        "name": "Test Policy",
        "type": "policy",
        "business_scope": None,  # Should use type default (empty string)
        "version_number": "1.0.0"
        # created_at missing - should use schema default (now())
        # is_active missing - should use schema default (true)
    }
    
    try:
        validated = validator.validate_tag("Policy", data_with_none)
        print("✓ Validation successful with None handling!")
        print(f"business_scope (was None): '{validated['business_scope']}'")
        print(f"created_at (was missing, datetime object): {validated['created_at']}")
        print(f"created_at type: {type(validated['created_at'])}")
        print(f"is_active (was missing): {validated['is_active']}")
    except ValidationError as e:
        print(f"✗ Validation failed: {e}")


if __name__ == "__main__":
    main()
