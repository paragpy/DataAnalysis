# generic_validator.py
from __future__ import annotations
from dataclasses import dataclass
from datetime import datetime, date, time, timezone
from pathlib import Path
import re
import typing as t

# Use stdlib tomllib (3.11+). Fallback to "toml" if needed.
try:
    import tomllib  # type: ignore
except Exception:  # pragma: no cover
    import toml as tomllib  # type: ignore


# =========================
# Errors
# =========================
class SchemaError(Exception): ...
class ValidationError(Exception): ...


# =========================
# Type mapping (vendor-agnostic)
# =========================
@dataclass(frozen=True)
class GenericType:
    """Abstract, DB-neutral type with optional constraints."""
    base: str               # 'string' | 'boolean' | 'integer' | 'number' | 'datetime' | 'date' | 'time'
    max_len: int | None = None

_VENDOR_TOKEN = re.compile(r"^\s*([A-Z_]+)\s*(?:\(\s*(\d+)\s*\))?\s*$")

def to_generic_type(token: str) -> GenericType:
    """
    Map vendor tokens (e.g., FIXED_STRING(200), STRING, BOOL, INT64, DOUBLE, TIMESTAMP)
    into abstract types with constraints.
    """
    if not isinstance(token, str):
        raise SchemaError(f"Type must be string, got {type(token).__name__}")

    tkn = token.strip().upper()

    # Common vendor aliases â†’ generic base
    if tkn.startswith("FIXED_STRING"):
        m = _VENDOR_TOKEN.match(tkn)
        if not m or not m.group(2):
            raise SchemaError(f"Invalid FIXED_STRING spec: {token!r}")
        return GenericType(base="string", max_len=int(m.group(2)))

    if tkn in {"STRING", "TEXT", "VARCHAR"}:
        return GenericType(base="string", max_len=None)

    if tkn in {"BOOL", "BOOLEAN"}:
        return GenericType(base="boolean")

    if tkn in {"INT", "INT8", "INT16", "INT32", "INT64", "INTEGER"}:
        return GenericType(base="integer")

    if tkn in {"FLOAT", "DOUBLE", "DECIMAL", "NUMERIC"}:
        return GenericType(base="number")

    if tkn in {"TIMESTAMP", "DATETIME", "ZONED_DATETIME"}:
        return GenericType(base="datetime")

    if tkn in {"DATE"}:
        return GenericType(base="date")

    if tkn in {"TIME"}:
        return GenericType(base="time")

    # Fallback: treat as string (safest neutral default)
    return GenericType(base="string")


# =========================
# Conversions
# =========================
_SEMVER_RE = re.compile(r"^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:[-+][A-Za-z0-9\.-]+)?$")

def _parse_datetime(val: t.Any) -> datetime:
    if isinstance(val, datetime):
        return val.astimezone(timezone.utc)
    if isinstance(val, (int, float)):
        return datetime.fromtimestamp(float(val), tz=timezone.utc)
    if isinstance(val, str):
        s = val.strip().lower()
        if s in {"now", "now()"}:
            return datetime.now(tz=timezone.utc)
        try:
            # supports "...Z"
            return datetime.fromisoformat(val.replace("Z", "+00:00")).astimezone(timezone.utc)
        except Exception:
            pass
    raise ValidationError(f"Invalid datetime: {val!r}")

def _parse_date(val: t.Any) -> date:
    if isinstance(val, date) and not isinstance(val, datetime):
        return val
    if isinstance(val, str):
        try:
            return date.fromisoformat(val)
        except Exception:
            pass
    raise ValidationError(f"Invalid date (YYYY-MM-DD): {val!r}")

def _parse_time(val: t.Any) -> time:
    if isinstance(val, time):
        return val
    if isinstance(val, str):
        try:
            return time.fromisoformat(val)
        except Exception:
            pass
    raise ValidationError(f"Invalid time (HH:MM[:SS[.ffffff]]): {val!r}")

def _to_bool(v: t.Any) -> bool:
    if isinstance(v, bool):
        return v
    if isinstance(v, (int, float)):
        return v != 0
    if isinstance(v, str):
        return v.strip().lower() in {"1", "true", "t", "yes", "y", "on"}
    raise ValidationError(f"Invalid boolean: {v!r}")

def coerce_value(val: t.Any, gtype: GenericType, *, truncate: bool = False) -> t.Any:
    b = gtype.base
    if b == "string":
        s = "" if val is None else str(val)
        if gtype.max_len is not None and len(s) > gtype.max_len:
            if truncate:
                return s[:gtype.max_len]
            raise ValidationError(f"String exceeds max_len {gtype.max_len}: {s!r}")
        return s

    if b == "boolean":
        return _to_bool(val)

    if b == "integer":
        try:
            return int(val)
        except Exception:
            raise ValidationError(f"Invalid integer: {val!r}")

    if b == "number":
        try:
            return float(val)
        except Exception:
            raise ValidationError(f"Invalid number: {val!r}")

    if b == "datetime":
        return _parse_datetime(val)

    if b == "date":
        return _parse_date(val)

    if b == "time":
        return _parse_time(val)

    # default: string
    return str(val)


# =========================
# Schema registry (generic)
# =========================
@dataclass
class PropertySpec:
    name: str
    gtype: GenericType
    nullable: bool
    default: t.Any | None = None
    comment: str | None = None
    regex: str | None = None          # optional additional constraint (generic)
    min_len: int | None = None        # optional
    max_len: int | None = None        # optional; overrides gtype.max_len if smaller
    choices: list[str] | None = None  # optional enum/choice list

@dataclass
class NodeType:
    name: str
    properties: dict[str, PropertySpec]

@dataclass
class RelType:
    name: str
    properties: dict[str, PropertySpec]  # may be empty

class GraphSchema:
    """
    Reads a TOML schema and exposes generic Node/Relationship types.
    Works with keys named 'tags'/'edges' (your current file) OR 'nodes'/'relationships'.
    """
    def __init__(self, raw: dict):
        self._raw = raw
        self.nodes: dict[str, NodeType] = {}
        self.rels: dict[str, RelType] = {}

        # Domain-level rules (generic)
        self.rules = {
            "require_non_empty_name": False,
            "require_semver_version": False,
            "allowed_types": None,           # enum for 'type' property values
            "enforce_id_length": None,       # generic name
            "enforce_vid_length": None,      # kept for backward compatibility
        }
        self._load()

    @staticmethod
    def from_toml(path_or_str: str | Path) -> "GraphSchema":
        p = Path(path_or_str)
        data = tomllib.load(p.open("rb")) if p.exists() else tomllib.loads(str(path_or_str))
        return GraphSchema(data)

    def _collect_entity_block(self, primary_key: str, fallback_key: str) -> dict:
        block = self._raw.get(primary_key)
        if block is None:
            block = self._raw.get(fallback_key, {})
        return block or {}

    def _load(self):
        # Nodes: prefer 'tags', fallback 'nodes'
        raw_nodes = self._collect_entity_block("tags", "nodes")
        for node_name, node_body in raw_nodes.items():
            ps: dict[str, PropertySpec] = {}
            for pn, pd in (node_body.get("properties") or {}).items():
                gtype = to_generic_type(pd["type"])
                ps[pn] = PropertySpec(
                    name=pn,
                    gtype=gtype,
                    nullable=bool(pd.get("nullable", True)),
                    default=pd.get("default"),
                    comment=pd.get("comment"),
                    # optional generic constraints if present
                    regex=pd.get("regex"),
                    min_len=pd.get("min_len"),
                    max_len=pd.get("max_len"),
                    choices=pd.get("choices"),
                )
            self.nodes[node_name] = NodeType(name=node_name, properties=ps)

        # Relationships: prefer 'edges', fallback 'relationships'
        raw_rels = self._collect_entity_block("edges", "relationships")
        for rel_name, rel_body in raw_rels.items():
            ps: dict[str, PropertySpec] = {}
            for pn, pd in (rel_body.get("properties") or {}).items():
                gtype = to_generic_type(pd["type"])
                ps[pn] = PropertySpec(
                    name=pn,
                    gtype=gtype,
                    nullable=bool(pd.get("nullable", True)),
                    default=pd.get("default"),
                    comment=pd.get("comment"),
                    regex=pd.get("regex"),
                    min_len=pd.get("min_len"),
                    max_len=pd.get("max_len"),
                    choices=pd.get("choices"),
                )
            self.rels[rel_name] = RelType(name=rel_name, properties=ps)

        # Generic validation rules block
        rules = (((self._raw.get("validation") or {}).get("rules")) or {})
        self.rules["require_non_empty_name"] = bool(rules.get("require_non_empty_name", False))
        self.rules["require_semver_version"] = bool(rules.get("require_semver_version", False))
        self.rules["allowed_types"] = rules.get("allowed_types")
        # accept either enforce_id_length or (legacy) enforce_vid_length
        self.rules["enforce_id_length"] = rules.get("enforce_id_length", rules.get("enforce_vid_length"))

    def get_node(self, name: str) -> NodeType:
        try:
            return self.nodes[name]
        except KeyError:
            raise SchemaError(f"Unknown node type: {name}")

    def get_rel(self, name: str) -> RelType:
        try:
            return self.rels[name]
        except KeyError:
            raise SchemaError(f"Unknown relationship type: {name}")


# =========================
# Validator (generic)
# =========================
@dataclass
class ValidationOptions:
    truncate_strings: bool = False     # truncate if over max_len
    forbid_unknown_props: bool = True  # error on extraneous fields

class GraphDataValidator:
    def __init__(self, schema: GraphSchema, options: ValidationOptions | None = None):
        self.schema = schema
        self.options = options or ValidationOptions()

    # ---------- public APIs ----------
    def validate_node_props(self, node_type: str, props: dict) -> dict:
        spec = self.schema.get_node(node_type)
        return self._validate_properties(props, spec.properties, f"Node[{node_type}]")

    def validate_rel_props(self, rel_type: str, props: dict) -> dict:
        spec = self.schema.get_rel(rel_type)
        return self._validate_properties(props, spec.properties, f"Relationship[{rel_type}]")

    def validate_id(self, id_value: str | None) -> str | None:
        if id_value is None:
            return None
        s = str(id_value)
        max_len = self.schema.rules.get("enforce_id_length")
        if isinstance(max_len, int) and len(s) > max_len:
            raise ValidationError(f"ID length {len(s)} exceeds enforced limit {max_len}")
        return s

    def validate_payload(self, payload: dict) -> dict:
        """
        Generic unified entry point.

        payload = {
          "entity": "node" | "tag" | "edge" | "relationship",
          "type": "Policy" | "HasContent" | ...,
          "id": "optional id/key for node",         # nodes only (generic)
          "props": { ... }
        }
        """
        entity = (payload.get("entity") or "").lower()
        etype  = payload.get("type")
        props  = payload.get("props") or {}
        pid    = payload.get("id")

        if entity not in {"node", "tag", "edge", "relationship"}:
            raise ValidationError("payload.entity must be 'node'/'tag' or 'edge'/'relationship'")

        if not etype or not isinstance(etype, str):
            raise ValidationError("payload.type must be a non-empty string")

        if entity in {"node", "tag"}:
            cleaned = self.validate_node_props(etype, props)
            return {"entity": "node", "type": etype, "id": self.validate_id(pid), "props": cleaned}

        cleaned = self.validate_rel_props(etype, props)
        return {"entity": "relationship", "type": etype, "props": cleaned}

    # ---------- internals ----------
    def _validate_properties(self, input_props: dict[str, t.Any], spec_map: dict[str, PropertySpec], ctx: str) -> dict:
        cleaned: dict[str, t.Any] = {}

        if self.options.forbid_unknown_props:
            unknown = set(input_props) - set(spec_map)
            if unknown:
                raise ValidationError(f"{ctx}: unknown properties: {sorted(unknown)}")

        for name, ps in spec_map.items():
            present = name in input_props
            raw = input_props.get(name)

            if not present or raw is None:
                if ps.default is not None:
                    val = self._evaluate_default(ps.default, ps)
                    cleaned[name] = self._coerce(val, ps)
                elif ps.nullable:
                    cleaned[name] = None
                else:
                    raise ValidationError(f"{ctx}: required non-null property '{name}' missing")
                continue

            cleaned[name] = self._coerce(raw, ps)

            # Extra generic constraints
            sval = cleaned[name]
            if ps.regex and sval is not None:
                if not re.compile(ps.regex).match(str(sval)):
                    raise ValidationError(f"{ctx}: property '{name}' does not match regex {ps.regex!r}")

            # min_len/max_len override (for strings)
            if ps.gtype.base == "string" and sval is not None:
                s = str(sval)
                if ps.min_len is not None and len(s) < ps.min_len:
                    raise ValidationError(f"{ctx}: property '{name}' shorter than min_len {ps.min_len}")
                # Use the smallest max among type-level and property-level if both present
                effective_max = min([x for x in [ps.gtype.max_len, ps.max_len] if x is not None], default=None)
                if effective_max is not None and len(s) > effective_max:
                    if self.options.truncate_strings:
                        cleaned[name] = s[:effective_max]
                    else:
                        raise ValidationError(f"{ctx}: property '{name}' exceeds max_len {effective_max}")
            # choices
            if ps.choices is not None and cleaned[name] is not None:
                val_norm = str(cleaned[name]).lower()
                if val_norm not in [str(x).lower() for x in ps.choices]:
                    raise ValidationError(f"{ctx}: property '{name}' must be one of {ps.choices}, got {cleaned[name]!r}")

        # pass-through unknowns if allowed
        if not self.options.forbid_unknown_props:
            for k, v in input_props.items():
                if k not in cleaned:
                    cleaned[k] = v

        self._apply_schema_rules(ctx, cleaned)
        return cleaned

    def _evaluate_default(self, default: t.Any, ps: PropertySpec) -> t.Any:
        if isinstance(default, str):
            d = default.strip().lower()
            if d in {"now", "now()"} and ps.gtype.base == "datetime":
                return datetime.now(tz=timezone.utc)
            if d in {"today", "today()"} and ps.gtype.base == "date":
                return date.today()
        return default

    def _coerce(self, value: t.Any, ps: PropertySpec) -> t.Any:
        try:
            return coerce_value(value, ps.gtype, truncate=self.options.truncate_strings)
        except ValidationError as e:
            raise ValidationError(f"Property '{ps.name}': {e}") from e

    # -------- domain-wide rules from [validation.rules] ----------
    def _apply_schema_rules(self, ctx: str, props: dict):
        rules = self.schema.rules

        if rules.get("require_non_empty_name") and "name" in props:
            if props["name"] is None or str(props["name"]).strip() == "":
                raise ValidationError(f"{ctx}: 'name' cannot be empty")

        if rules.get("require_semver_version") and "version_number" in props and props["version_number"] is not None:
            if not _SEMVER_RE.match(str(props["version_number"])):
                raise ValidationError(f"{ctx}: 'version_number' must follow semver (e.g., 1.2.3)")

        allowed = rules.get("allowed_types")
        if allowed and "type" in props and props["type"] is not None:
            tval = str(props["type"]).lower()
            if tval not in [str(x).lower() for x in allowed]:
                raise ValidationError(f"{ctx}: 'type' must be one of {allowed}, got {props['type']!r}")


from generic_validator import GraphSchema, GraphDataValidator, ValidationOptions

schema = GraphSchema.from_toml("sample_schemt.toml")  # your current file
validator = GraphDataValidator(schema, ValidationOptions(truncate_strings=False))

# Validate a node (aka 'tag' in your file)
props_in = {
    "name": "Information Security Policy",
    "type": "policy",
    "business_scope": "ISMS",
    "version_number": "1.0.0",
    "created_at": "now()",     # will coerce to datetime (UTC)
    "is_active": True
}
clean_node = validator.validate_node_props("Policy", props_in)
print(clean_node)

# Validate a relationship (aka 'edge' in your file)
clean_rel = validator.validate_rel_props("HasContent", {})
print(clean_rel)

# Unified payload (DB-agnostic)
payload = {
    "entity": "node",          # 'node' or 'relationship' (also accepts 'tag'/'edge')
    "type": "Policy",
    "id": "POLICY-0001",       # optional; enforced by enforce_id_length if set
    "props": props_in
}
clean_payload = validator.validate_payload(payload)
print(clean_payload)

